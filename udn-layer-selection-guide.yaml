# UDN Layer Selection Guide
# Based on Chaos UDN Service Unavailability Test Results

apiVersion: v1
kind: ConfigMap
metadata:
  name: udn-layer-selection-guide
  namespace: openshift-config
data:
  layer-selection-matrix.yaml: |
    # UDN Layer Selection Decision Matrix
    
    workload_profiles:
      memory_constrained:
        description: "Workloads with limited memory allocation"
        examples:
          - "Microservices with <512MB containers"
          - "Edge computing deployments"
          - "High-density pod scheduling"
        recommended_layer: "layer2"
        rationale: "21% memory savings (93MB vs 116MB per OVN process)"
        trade_offs:
          cpu_overhead: "+5% CPU usage"
          latency_benefit: "-4.9% better P99 latency"
        
      cpu_constrained:
        description: "Workloads with limited CPU allocation"
        examples:
          - "CPU-intensive applications"
          - "Batch processing workloads"
          - "Scientific computing"
        recommended_layer: "layer3"
        rationale: "5% CPU savings (4.44% vs 4.68% usage)"
        trade_offs:
          memory_overhead: "+25% memory usage"
          latency_penalty: "+4.9% higher P99 latency"
          
      balanced_workloads:
        description: "Workloads with balanced resource requirements"
        examples:
          - "Web applications"
          - "API services"
          - "Database workloads"
        decision_criteria:
          - memory_budget_gb: ">= 2GB per pod"
          - cpu_budget_cores: ">= 1 core per pod"
          - latency_tolerance_ms: "<= 100ms P99"
        recommended_layer: "layer2"
        rationale: "Better latency characteristics for user-facing apps"
        
      high_availability_critical:
        description: "Mission-critical workloads requiring maximum resilience"
        examples:
          - "Financial trading systems"
          - "Healthcare applications"
          - "Real-time monitoring"
        recommended_layer: "layer2"
        rationale: "Lower baseline latency + consistent chaos impact"
        chaos_resilience:
          latency_degradation: "3.0% during master failures"
          memory_impact: "Slight improvement during chaos"
          cpu_impact: "No negative impact"

  sizing-calculator.yaml: |
    # Resource Sizing Calculator for UDN Layers
    
    layer2_sizing:
      ovn_memory_per_node: "93MB"
      ovn_cpu_per_node: "4.68%"
      baseline_p99_latency: "57.6s"
      chaos_latency_penalty: "+3.0%"
      
    layer3_sizing:
      ovn_memory_per_node: "116MB"  # +25% vs Layer 2
      ovn_cpu_per_node: "4.44%"     # -5% vs Layer 2
      baseline_p99_latency: "60.4s"  # +4.9% vs Layer 2
      chaos_latency_penalty: "+2.8%"
      
    capacity_formulas:
      layer2_memory_overhead: |
        # Memory overhead per worker node
        total_memory_overhead = nodes * 93MB
        # For 100 nodes: 9.3GB total OVN memory
        
      layer3_memory_overhead: |
        # Memory overhead per worker node  
        total_memory_overhead = nodes * 116MB
        # For 100 nodes: 11.6GB total OVN memory (+2.3GB vs Layer 2)
        
      breakeven_analysis: |
        # When Layer 3 becomes cost-effective
        if cpu_cost_per_core > memory_cost_per_gb * 1.25:
            recommended = "layer3"
        else:
            recommended = "layer2"

  implementation-templates.yaml: |
    # Implementation Templates
    
    layer2_udn_config: |
      apiVersion: k8s.ovn.org/v1
      kind: UserDefinedNetwork
      metadata:
        name: layer2-workload-net
      spec:
        topology: Layer2
        layer2:
          role: Primary
          subnets:
          - "10.128.0.0/16"
        
    layer3_udn_config: |
      apiVersion: k8s.ovn.org/v1
      kind: UserDefinedNetwork
      metadata:
        name: layer3-workload-net
      spec:
        topology: Layer3
        layer3:
          role: Primary
          subnets:
          - "10.132.0.0/16" 