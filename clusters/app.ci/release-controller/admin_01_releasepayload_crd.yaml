apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: (devel)
  creationTimestamp: null
  name: releasepayloads.release.openshift.io
spec:
  group: release.openshift.io
  names:
    kind: ReleasePayload
    listKind: ReleasePayloadList
    plural: releasepayloads
    singular: releasepayload
  scope: Namespaced
  versions:
    - name: v1alpha1
      schema:
        openAPIV3Schema:
          description: "ReleasePayload encapsulates the information for the creation of a ReleasePayload and aggregates the results of its respective verification tests. \n The release-controller is configured to monitor imagestreams, in a specific namespace, that are annotated with a ReleaseConfig.  The ReleaseConfig is a definition of how releases are calculated.  When a ReleasePayload is generated, it will be generated in the same namespace as the imagstream that produced it. If/when an update occurs, to one of these imagestreams, the release-controller will: 1. Create a point-in-time mirror of the updated imagestream 2. Create a new Release from the mirror - Any errors before this point will cause the release to marked `Failed` 3. Launches a set of release analysis jobs 4. Launches an aggregation job 5. Launches a set of release verification jobs - These can either be `Blocking Jobs` which will prevent release acceptance or `Informing Jobs` which will not prevent release acceptance. 6. For Stable releases, launches a set of jobs to test a subset of the supported upgrades defined inside the release image itself.  While these jobs do not have any real bearing on the acceptance or rejection of a ReleasePayload, they will be monitored and their respective results captured.  The hope would be to use these results to provide a convenient way to override a \"Rejected\" release caused by a blocking upgrade job. 7. Monitors for job completions - If all `Blocking Jobs` complete successfully, then the release is `Accepted`.  If any `Blocking Jobs` fail, the release will be marked `Rejected` 8. Publishes all results to the respective webpage \n Example: ART: 1. Publishes an update to the `ocp/4.9-art-latest` imagestream \n Release-controller: 1. Creates a mirror named: `ocp/4.9-art-latest-2021-09-27-105859` 2. Creates a ReleasePayload: `ocp/4.9.0-0.nightly-2021-09-27-105859` -Labels: release.openshift.io/imagestream=release release.openshift.io/imagestreamtag-name=4.9.0-0.nightly-2021-09-27-105859 3. Creates an OpenShift Release: `ocp/release:4.9.0-0.nightly-2021-09-27-105859` 4. Update ReleasePayload conditions with results of release creation job If the release was created successfully, the release-controller: 5. Launches: 4.9.0-0.nightly-2021-09-27-105859-aggregated-<name>-analysis-<count> 6. Launches: 4.9.0-0.nightly-2021-09-27-105859-aggregated-<name>-aggregator 7. Launches: 4.9.0-0.nightly-2021-09-27-105859-<name> \n When ART promotes a GA release, they will assemble releases themselves, publish it to quay.io, and then update the \"stable\" release stream (i.e. ocp/release) with the corresponding payload.  In this scenario, the release-controller will perform all the same steps, mentioned above, but the mirror will be named after the \"official\" release (i.e. 4.9.7) and not not contain a timestamp.  Likewise, any verification tests will only contain the release name and the name of the verification test as defined in the ReleaseConfig.  The release-controller will also launch a small sample of jobs to test upgrades from the list of upgrade versions defined inside the release image itse